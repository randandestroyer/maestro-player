<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Maestro Player — Web Audio (with Seek & Download)</title>
<style>
  :root { --bg:#0b0b0f; --fg:#e8e8ee; --muted:#9aa0a6; --accent:#60a5fa; --accent2:#22c55e; --card:#14141a; }
  html,body{background:var(--bg);color:var(--fg);font-family:-apple-system,system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0}
  .wrap{max-width:860px;margin:24px auto;padding:0 16px}
  h1{font-size:22px;margin:12px 0 4px}
  p{color:var(--muted);margin:6px 0}
  .card{background:var(--card);border:1px solid #22232a;border-radius:14px;padding:14px;margin:12px 0}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button{background:#111827;color:#f9fafb;border:1px solid #1f2937;border-radius:12px;padding:10px 14px;cursor:pointer}
  button:disabled{opacity:.6;cursor:not-allowed}
  input[type=range]{width:100%}
  select,textarea{background:#0f1117;color:var(--fg);border:1px solid #1f2230;border-radius:10px;padding:10px;width:100%}
  .pill{padding:6px 10px;border-radius:999px;background:#1b1e27;color:#cbd5e1;border:1px solid #2a2f3b}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;font-size:12px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media (max-width:720px){.grid{grid-template-columns:1fr}}
  .ok{background:#11321f;color:#c7f9cc}.bad{background:#3a1313;color:#fca5a5}
</style>
</head>
  <audio id="bgPlayer" preload="auto" playsinline style="display:none"></audio>
<body>
<div class="wrap">
  <h1>Maestro Player <span class="pill">Web Audio</span></h1>
  <p>Tap <b>Start</b> once (iOS needs a user gesture). Keep Safari foregrounded and Silent Mode off. Headphones recommended.</p>

  <div class="card">
    <div class="row">
      <button id="startBtn">Start</button>
      <button id="pauseBtn" disabled>Pause</button>
      <button id="resumeBtn" disabled>Resume</button>
      <button id="stopBtn" disabled>Stop</button>
      <span id="status" class="pill">Idle</span>
    </div>

    <div class="row" style="width:100%">
      <input id="seek" type="range" min="0" max="900" step="1" value="0" />
    </div>
    <div class="row" style="justify-content:space-between;width:100%">
      <span id="clock">00:00 / 15:00</span>
      <span id="seekHint" class="mono" style="color:#9aa0a6"></span>
    </div>
  </div>

  <div class="card">
    <div class="grid">
      <div>
        <label>Preset</label>
        <select id="presetSelect"></select>
        <p class="mono" id="presetInfo"></p>
      </div>
      <div>
        <label>Master Volume</label>
        <input id="masterVol" type="range" min="0" max="1" step="0.01" value="0.9">
      </div>
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Import Custom Preset (JSON)</h3>
    <p class="mono">{"name":"My Preset","lengthSec":900,"stages":[[startSec,durationSec,[freqs...],pulseStartHz,pulseEndHz,[vols...]], ...]}</p>
    <textarea id="presetJson" rows="6" placeholder='Paste preset JSON here'></textarea>
    <div class="row" style="margin-top:8px">
      <button id="loadJson">Load JSON Preset</button>
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Export / Download</h3>
    <div class="row">
      <button id="recordBtn" disabled>Start Live Record</button>
      <button id="saveBtn" disabled>Stop & Save</button>
      <button id="offlineBtn">Quick Render (WAV)</button>
    </div>
    <p class="mono" id="dlInfo"></p>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">What this does</h3>
    <ul>
      <li>Monaural sine oscillators layered at target resonances (38 / 74 / 18 / 120 Hz; then 20 Hz drop)</li>
      <li>Isochronic gate (sine→square waveshaper) ramping pulse per stage</li>
      <li>Preprogrammed 5‑stage crescendo totaling 15:00</li>
      <li><b>New:</b> Pause/Resume, Seek, and Download (Record or Quick Render)</li>
    </ul>
  </div>
</div>

<script>
(() => {
  // ======= Preset(s) =======
  const PRESETS = [
    {
      name: "Wet Plap Crescendo (15:00)",
      lengthSec: 900,
      stages: [
        [   0, 180, [38],                 1.5, 2.0, [0.60] ],
        [ 180, 240, [38, 74],             2.0, 3.5, [0.75, 0.50] ],
        [ 420, 240, [38, 74, 18],         3.5, 5.0, [0.85, 0.50, 0.40] ],
        [ 660, 180, [38, 74, 18, 120],    5.0, 7.5, [1.00, 0.60, 0.50, 0.50] ],
        [ 840,  60, [20, 38],             1.0, 1.0, [0.80, 0.30] ]
      ]
    },
  {
  name: "Capture Ritual (Chest Punch) — 30:00",
  lengthSec: 1800,
  stages: [
    [0,15,[96,120],8.0,7.0,[0.80,0.30]],
    [15,15,[96,120],7.0,6.5,[0.30,0.80]],
    [30,15,[96,120],6.5,6.0,[0.80,0.30]],
    [45,15,[96,120],6.0,6.0,[0.30,0.80]],
    [60,60,[100,120],6.0,5.0,[0.70,0.60]],
    [120,60,[104,118],5.0,4.5,[0.75,0.65]],
    [180,60,[106,116],4.5,4.0,[0.80,0.70]],
    [240,60,[107,114],4.0,3.5,[0.85,0.75]],
    [300,60,[108],3.5,3.2,[1.00]],
    [360,60,[108,74,38],2.2,2.2,[1.00,0.70,0.60]],
    [420,60,[108,74,38],2.4,2.4,[1.00,0.70,0.60]],
    [480,60,[108,74,38],2.2,2.2,[1.00,0.70,0.60]],
    [540,60,[108,74,38],2.4,2.4,[1.00,0.70,0.60]],
    [600,60,[108,74,38],2.2,2.2,[1.00,0.70,0.60]],
    [660,60,[108,74,38],2.4,2.4,[1.00,0.70,0.60]],
    [720,60,[108,74,38],2.2,2.2,[1.00,0.70,0.60]],
    [780,60,[108,74,38],2.4,2.4,[1.00,0.70,0.60]],
    [840,60,[108,74,38],2.2,2.2,[1.00,0.70,0.60]],
    [900,60,[108,74,38],2.4,2.4,[1.00,0.70,0.60]],
    [960,60,[108,74,38],2.2,2.2,[1.00,0.70,0.60]],
    [1020,60,[108,74,38],2.4,2.4,[1.00,0.70,0.60]],
    [1080,60,[108,74,38],2.2,2.2,[1.00,0.70,0.60]],
    [1140,60,[108,74,38],2.4,2.4,[1.00,0.70,0.60]],
    [1200,60,[108,74,38],2.2,2.2,[1.00,0.70,0.60]],
    [1260,60,[108,74,38],2.4,2.4,[1.00,0.70,0.60]],
    [1320,60,[108,74,38],2.2,2.2,[1.00,0.70,0.60]],
    [1380,60,[108,74,38],2.4,2.4,[1.00,0.70,0.60]],
    [1440,60,[108,74,38],2.2,2.2,[1.00,0.70,0.60]],
    [1500,60,[108,74,38],2.4,2.4,[1.00,0.70,0.60]],
    [1560,120,[108,74,38],2.3,2.3,[1.00,0.65,0.55]],
    [1680,120,[108,74,38],2.3,2.3,[0.95,0.60,0.50]]
  ]
},
    {
  name: "Breast Worship – Soft Start (60:00)",
  lengthSec: 3600,
  stages: [
    // Slow, reverent pulses – the first lingering glances
    [0, 300, [22], 1.0, 1.2, [0.45]],

    // Gentle lift-and-drop sway – bounce begins to catch your eye
    [300, 300, [22, 38], 1.2, 1.5, [0.45, 0.30]],

    // Warm undertones, imagining the weight in your hands
    [600, 300, [22, 38, 74], 1.5, 1.8, [0.50, 0.30, 0.25]],

    // A little more bounce, eyes fixed, mouth dry
    [900, 300, [38, 74, 108], 1.8, 2.0, [0.50, 0.30, 0.25]],

    // Chest-to-heart connection – steady, needy rhythm
    [1200, 300, [38, 108], 2.0, 2.2, [0.55, 0.30]],

    // The slow tease – pulse grows deeper but stays soft
    [1500, 300, [22, 38, 74], 2.2, 2.5, [0.55, 0.35, 0.25]],

    // Locked in – every sway feels heavier
    [1800, 300, [38, 74, 108], 2.5, 2.7, [0.60, 0.35, 0.25]],

    // Almost hypnotized – the bounce owns you now
    [2100, 300, [38, 74, 108, 120], 2.7, 2.9, [0.60, 0.35, 0.25, 0.20]],

    // Final soft climax – warm, lingering, satisfied
    [2400, 1200, [22, 38], 2.5, 2.0, [0.50, 0.30]]
  ]
},
{
  name: "Monster Unleashed (Monaural Growth Stack) — 90:00",
  lengthSec: 5400,
  stages: [
    [0,360,[66,40,23,88],2.2,2.6,[1.00,0.75,0.55,0.65]],
    [360,180,[66,40,23,88,528],3.0,3.2,[1.00,0.75,0.55,0.65,0.30]],
    [540,60,[66,40,23,88],6.0,2.4,[1.00,0.75,0.55,0.65]],

    [600,360,[66,40,23,88],2.2,2.7,[1.00,0.75,0.55,0.65]],
    [960,180,[66,40,23,88,528],3.0,3.2,[1.00,0.75,0.55,0.65,0.30]],
    [1140,60,[66,40,23,88],6.5,2.5,[1.00,0.75,0.55,0.65]],

    [1200,360,[66,40,23,88],2.3,2.7,[1.00,0.75,0.55,0.65]],
    [1560,180,[66,40,23,88,528],3.1,3.3,[1.00,0.75,0.55,0.65,0.30]],
    [1740,60,[66,40,23,88],6.5,2.6,[1.00,0.75,0.55,0.65]],

    [1800,360,[66,40,23,88],2.3,2.8,[1.00,0.75,0.55,0.65]],
    [2160,180,[66,40,23,88,528],3.1,3.3,[1.00,0.75,0.55,0.65,0.30]],
    [2340,60,[66,40,23,88],6.8,2.6,[1.00,0.75,0.55,0.65]],

    [2400,360,[66,40,23,88],2.4,2.8,[1.00,0.75,0.55,0.65]],
    [2760,180,[66,40,23,88,528],3.2,3.4,[1.00,0.75,0.55,0.65,0.30]],
    [2940,60,[66,40,23,88],7.0,2.7,[1.00,0.75,0.55,0.65]],

    [3000,360,[66,40,23,88],2.4,2.9,[1.00,0.75,0.55,0.65]],
    [3360,180,[66,40,23,88,528],3.2,3.4,[1.00,0.75,0.55,0.65,0.30]],
    [3540,60,[66,40,23,88],7.0,2.7,[1.00,0.75,0.55,0.65]],

    [3600,360,[66,40,23,88],2.5,2.9,[1.00,0.75,0.55,0.65]],
    [3960,180,[66,40,23,88,528],3.2,3.5,[1.00,0.75,0.55,0.65,0.30]],
    [4140,60,[66,40,23,88],7.2,2.8,[1.00,0.75,0.55,0.65]],

    [4200,360,[66,40,23,88],2.5,3.0,[1.00,0.75,0.55,0.65]],
    [4560,180,[66,40,23,88,528],3.3,3.5,[1.00,0.75,0.55,0.65,0.30]],
    [4740,60,[66,40,23,88],7.2,2.8,[1.00,0.75,0.55,0.65]],

    [4800,360,[66,40,23,88],2.6,3.0,[1.00,0.75,0.55,0.65]],
    [5160,180,[66,40,23,88,528],3.3,3.6,[1.00,0.75,0.55,0.65,0.30]],
    [5340,60,[66,40,23,88],7.5,2.9,[1.00,0.75,0.55,0.65]]
  ]
},
{
  name: "Futa Breeder’s Hour (60:00)",
  lengthSec: 3600,
  stages: [
    [   0, 300, [66,40,23],         1.8, 2.2, [1.00,0.70,0.55] ],
    [ 300, 300, [66,40,23],         2.2, 2.6, [1.00,0.70,0.55] ],

    [ 600, 300, [66,40,23,88],      2.6, 3.0, [1.00,0.70,0.50,0.35] ],
    [ 900, 300, [66,40,23,88],      3.0, 3.4, [1.00,0.70,0.50,0.35] ],

    [1200, 300, [66,40,23,108],     3.4, 4.0, [1.00,0.65,0.50,0.40] ],
    [1500, 300, [66,40,23,108],     4.0, 4.6, [1.00,0.65,0.50,0.40] ],

    [1800, 300, [66,40,23,108,88],  4.6, 5.2, [1.00,0.65,0.50,0.45,0.30] ],
    [2100, 300, [66,40,23,108,88],  5.2, 5.8, [1.00,0.65,0.50,0.45,0.30] ],

    [2400, 300, [66,40,23,108,74],  5.8, 6.4, [1.00,0.65,0.50,0.45,0.30] ],
    [2700, 300, [66,40,23,108,74],  6.4, 7.0, [1.00,0.65,0.50,0.45,0.30] ],

    [3000, 240, [66,40,23,108,88,74], 7.0, 7.2, [1.00,0.65,0.50,0.45,0.30,0.30] ],
    [3240, 240, [66,40,23,108,88,74], 7.2, 7.4, [1.00,0.65,0.50,0.45,0.30,0.30] ],

    [3480, 120, [66,40,23,108,88],  7.4, 7.6, [1.00,0.65,0.50,0.45,0.30] ]
  ]
},
{
  name: "Futa Forge: Fueled Fortification (45:00, Mono)",
  lengthSec: 2700,
  stages: [
    // 0–5: entry melt — fat-to-cock rule introduced
    [   0, 300, [66,23],                 1.6, 1.8, [1.00,0.65] ],
    // 5–10: add base thickness carrier
    [ 300, 300, [66,23,40],              1.8, 2.0, [1.00,0.65,0.55] ],
    // 10–15: gentle stretch cue joins
    [ 600, 300, [66,23,40,88],           2.0, 2.2, [1.00,0.65,0.55,0.30] ],
    // 15–20: deepen the flow
    [ 900, 300, [66,23,40,88],           2.2, 2.6, [1.00,0.65,0.55,0.30] ],
    // 20–25: vascular/prostate driver engages softly
    [1200, 300, [66,23,40,88,108],       2.6, 3.0, [1.00,0.60,0.50,0.30,0.35] ],
    // 25–30: steady forging, same stack, slightly stronger pulse
    [1500, 300, [66,23,40,88,108],       3.0, 3.4, [1.00,0.60,0.50,0.30,0.35] ],
    // 30–35: subtle mass “seal” tone
    [1800, 300, [66,23,40,88,108,74],    3.4, 3.6, [1.00,0.60,0.50,0.28,0.35,0.25] ],
    // 35–40: hold and reinforce (no jolts)
    [2100, 300, [66,23,40,88,108,74],    3.6, 3.8, [1.00,0.60,0.50,0.28,0.35,0.25] ],
    // 40–45: loop-safe finish; ease toward core while staying potent
    [2400, 300, [66,23,40,88,108],       3.8, 4.0, [1.00,0.62,0.52,0.28,0.34] ]
  ]
};
]
  
  // ======= DOM =======
  const startBtn = document.getElementById('startBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const resumeBtn= document.getElementById('resumeBtn');
  const stopBtn  = document.getElementById('stopBtn');
  const statusEl = document.getElementById('status');
  const clockEl  = document.getElementById('clock');
  const seekEl   = document.getElementById('seek');
  const seekHint = document.getElementById('seekHint');
  const presetSel= document.getElementById('presetSelect');
  const presetInfo=document.getElementById('presetInfo');
  const presetJson=document.getElementById('presetJson');
  const loadJsonBtn=document.getElementById('loadJson');
  const masterVol= document.getElementById('masterVol');
  const recordBtn= document.getElementById('recordBtn');
  const saveBtn  = document.getElementById('saveBtn');
  const offlineBtn=document.getElementById('offlineBtn');
  const dlInfo   = document.getElementById('dlInfo');

  // ======= State =======
  let ctx, master, running=false, paused=false;
  let baseStartPerf=0, elapsedWhenPaused=0, rafId=null;
  let selectedPreset = PRESETS[0];
  let activeStops=[];
  let mediaRecorder=null, recordedChunks=[];

  // ======= Helpers =======
  const fmt = s => {
    s = Math.max(0, s|0);
    const m = (s/60)|0, r = s%60;
    return `${m}:${r<10?'0'+r:r}`;
  };
  const setStatus = (msg, ok=true)=>{ statusEl.textContent=msg; statusEl.className='pill '+(ok?'ok':'bad'); };

  function loadPresetList(){
    presetSel.innerHTML='';
    PRESETS.forEach((p,i)=>{
      const opt=document.createElement('option'); opt.value=i; opt.textContent=p.name; presetSel.appendChild(opt);
    });
    presetSel.value=PRESETS.indexOf(selectedPreset);
    presetInfo.textContent = `${selectedPreset.name} • ${Math.round(selectedPreset.lengthSec/60)} min`;
    seekEl.max = selectedPreset.lengthSec;
  }
  loadPresetList();

  presetSel.addEventListener('change', ()=>{
    selectedPreset = PRESETS[parseInt(presetSel.value,10)];
    presetInfo.textContent = `${selectedPreset.name} • ${Math.round(selectedPreset.lengthSec/60)} min`;
    seekEl.max = selectedPreset.lengthSec;
  });

  loadJsonBtn.addEventListener('click', ()=>{
    try{
      const obj = JSON.parse(presetJson.value.trim());
      if (!obj || !obj.stages || !Array.isArray(obj.stages)) throw new Error('Invalid preset JSON');
      if (!obj.lengthSec){
        let maxEnd=0; obj.stages.forEach(s=>maxEnd=Math.max(maxEnd, s[0]+s[1])); obj.lengthSec=maxEnd;
      }
      PRESETS.push(obj); selectedPreset=obj; loadPresetList(); setStatus('Loaded custom preset.');
    }catch(e){ setStatus('Preset JSON error: '+e.message,false); }
  });

  // ======= Audio graph builders =======
  function makeSquareShaper(){
    const shaper = ctx.createWaveShaper();
    const curve = new Float32Array(256);
    for (let i=0;i<256;i++){ const x=(i/255)*2-1; curve[i]=(x>=0?1:-1); }
    shaper.curve=curve; shaper.oversample='4x';
    return shaper;
  }

  function makeIsoGate(pStart, pEnd, t0, dur){
    const lfo = ctx.createOscillator();
    const shaper = makeSquareShaper();
    const lfoGain = ctx.createGain();
    const bias = ctx.createConstantSource();
    const gate = ctx.createGain();

    lfo.type='sine';
    lfo.connect(shaper); shaper.connect(lfoGain);
    lfoGain.gain.value=0.5; bias.offset.value=0.5;
    lfoGain.connect(gate.gain); bias.connect(gate.gain);

    lfo.frequency.setValueAtTime(pStart, t0);
    lfo.frequency.linearRampToValueAtTime(pEnd, t0+dur);
    lfo.start(t0); bias.start(t0);

    return { node:gate, stop:(t)=>{ try{lfo.stop(t);}catch(_){} try{bias.stop(t);}catch(_){} } };
  }

  function scheduleFromOffset(offsetSec){
    // Clear any previous
    activeStops.forEach(fn=>{ try{fn(ctx.currentTime+0.01);}catch(_){} }); activeStops=[];
    if (master) try{ master.disconnect(); }catch(_){}
    master = ctx.createGain(); master.gain.value=parseFloat(masterVol.value||"0.9"); master.connect(ctx.destination);

    const T = selectedPreset.lengthSec;
    const startAt = ctx.currentTime + 0.05;
    const rel = (s)=>startAt + Math.max(0, s - offsetSec);

    selectedPreset.stages.forEach(stage=>{
      const [s, dur, freqs, p0, p1, vols] = stage;
      const stageEnd = s + dur;
      if (stageEnd <= offsetSec) return; // entirely before offset

      const segStart = Math.max(s, offsetSec);
      const segDur = stageEnd - segStart;
      const pStart = p0 + (p1 - p0) * ((segStart - s)/dur);
      const pEnd   = p0 + (p1 - p0) * ((segStart - s + segDur)/dur);

      const gateObj = makeIsoGate(pStart, pEnd, rel(segStart), segDur);
      const stageMaster = ctx.createGain();
      gateObj.node.connect(stageMaster).connect(master);

      freqs.forEach((f, idx)=>{
        const osc = ctx.createOscillator(); const g=ctx.createGain();
        osc.type='sine'; osc.frequency.setValueAtTime(f, rel(segStart));
        g.gain.setValueAtTime((vols && vols[idx]!=null)?vols[idx]:0.5, rel(segStart));
        osc.connect(g).connect(gateObj.node);
        osc.start(rel(segStart)); osc.stop(rel(segStart)+segDur+0.02);
        activeStops.push((t)=>{ try{osc.stop(t);}catch(_){}}); 
      });

      // fadeout if we include final stage
      if (stageEnd >= T && segStart <= T-15) {
        const fadeStart = rel(segStart) + segDur - 15;
        stageMaster.gain.linearRampToValueAtTime(stageMaster.gain.value, fadeStart);
        stageMaster.gain.linearRampToValueAtTime(0.0001, rel(segStart)+segDur);
      }

      activeStops.push(gateObj.stop);
    });
  }

  // ======= Transport =======
  function nowElapsed(){
    if (!running) return 0;
    const base = paused ? elapsedWhenPaused*1000 : (performance.now() - baseStartPerf) + elapsedWhenPaused*1000;
    return Math.min(selectedPreset.lengthSec, Math.floor(base/1000));
  }

  function startAt(offset=0){
    running=true; paused=false; startBtn.disabled=true; stopBtn.disabled=false; pauseBtn.disabled=false; resumeBtn.disabled=true;
    setStatus('Playing…');
    if (!ctx) ctx = new (window.AudioContext||window.webkitAudioContext)({latencyHint:'interactive'});
    scheduleFromOffset(offset);
    baseStartPerf = performance.now();
    elapsedWhenPaused = offset;

    // enable record button
    recordBtn.disabled = !('MediaRecorder' in window);

    tick();
  }

  function pause(){
    if (!running || paused) return;
    paused=true; pauseBtn.disabled=true; resumeBtn.disabled=false;
    elapsedWhenPaused = nowElapsed();
    activeStops.forEach(fn=>{ try{fn(ctx.currentTime+0.01);}catch(_){}}); activeStops=[];
    setStatus('Paused');
  }

  function resume(){
    if (!running || !paused) return;
    startAt(elapsedWhenPaused);
  }

  function stopAll(){
    running=false; paused=false;
    if (rafId) cancelAnimationFrame(rafId);
    activeStops.forEach(fn=>{ try{fn(ctx.currentTime+0.01);}catch(_){}}); activeStops=[];
    if (ctx && ctx.state!=='closed'){ try{ctx.close();}catch(_){}} ctx=null;
    startBtn.disabled=false; stopBtn.disabled=true; pauseBtn.disabled=true; resumeBtn.disabled=true;
    recordBtn.disabled=true; saveBtn.disabled=true;
    setStatus('Stopped.');
    seekEl.value=0; clockEl.textContent=`00:00 / ${fmt(selectedPreset.lengthSec)}`;
  }

  function tick(){
    if (!running) return;
    const el = nowElapsed();
    seekEl.value = el;
    clockEl.textContent = `${fmt(el)} / ${fmt(selectedPreset.lengthSec)}`;
    if (el >= selectedPreset.lengthSec){ stopAll(); setStatus('Done • '+fmt(selectedPreset.lengthSec)); return; }
    rafId = requestAnimationFrame(tick);
  }

  // ======= Recording (real‑time) =======
  function startRecord(){
    if (!ctx) return setStatus('Start playback first.', false);
    if (!('MediaRecorder' in window)) return setStatus('Recorder not supported here.', false);
    // Route audio to MediaRecorder
    const dest = ctx.createMediaStreamDestination();
    master.disconnect(); master.connect(dest); master.connect(ctx.destination);
    mediaRecorder = new MediaRecorder(dest.stream);
    recordedChunks=[]; mediaRecorder.ondataavailable = e => { if (e.data.size>0) recordedChunks.push(e.data); };
    mediaRecorder.onstop = ()=>{
      const mime = mediaRecorder.mimeType || 'audio/webm';
      const blob = new Blob(recordedChunks, {type:mime});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href=url; a.download='maestro-recording.webm';
      a.click(); URL.revokeObjectURL(url);
      dlInfo.textContent = `Saved recording (${mime}).`;
    };
    mediaRecorder.start();
    saveBtn.disabled=false; setStatus('Recording…');
  }
  function stopRecord(){
    if (mediaRecorder && mediaRecorder.state!=='inactive'){ mediaRecorder.stop(); }
    saveBtn.disabled=true;
  }

  // ======= Offline Render (fast WAV, desktop‑friendly) =======
  async function quickRender(){
    dlInfo.textContent = 'Rendering… (WAV)';
    try{
      const sr = 44100;
      const len = selectedPreset.lengthSec * sr;
      const off = new OfflineAudioContext(1, len, sr);
      // build graph in offline context
      const master = off.createGain(); master.gain.value=parseFloat(masterVol.value||"0.9"); master.connect(off.destination);

      function makeSquareShaper(offctx){
        const sh = offctx.createWaveShaper();
        const curve = new Float32Array(256);
        for (let i=0;i<256;i++){ const x=(i/255)*2-1; curve[i]=(x>=0?1:-1); }
        sh.curve=curve; sh.oversample='4x'; return sh;
      }
      function makeIsoGate(pStart,pEnd,t0,dur){
        const lfo = off.createOscillator();
        const shaper = makeSquareShaper(off);
        const g = off.createGain(); const bias = off.createConstantSource();
        lfo.type='sine'; lfo.connect(shaper); const lfoGain=off.createGain(); shaper.connect(lfoGain);
        lfoGain.gain.value=0.5; bias.offset.value=0.5; lfoGain.connect(g.gain); bias.connect(g.gain);
        lfo.frequency.setValueAtTime(pStart, t0); lfo.frequency.linearRampToValueAtTime(pEnd, t0+dur);
        lfo.start(t0); bias.start(t0); return {node:g};
      }

      selectedPreset.stages.forEach(([s,dur,freqs,p0,p1,vols])=>{
        const gate = makeIsoGate(p0,p1,s,dur).node;
        const stageMaster = off.createGain(); gate.connect(stageMaster).connect(master);
        freqs.forEach((f,i)=>{
          const osc = off.createOscillator(); const g=off.createGain();
          osc.type='sine'; osc.frequency.setValueAtTime(f, s);
          g.gain.setValueAtTime((vols && vols[i]!=null)?vols[i]:0.5, s);
          osc.connect(g).connect(gate); osc.start(s); osc.stop(s+dur+0.02);
        });
        // fade last 15s if final stage covers end
        const T=selectedPreset.lengthSec;
        if (s+dur>=T && s<=T-15){ const fade=stageMaster.gain; fade.linearRampToValueAtTime(fade.value, T-15); fade.linearRampToValueAtTime(0.0001, T); }
      });

      const buf = await off.startRendering();
      // encode WAV
      const wav = bufferToWav(buf);
      const url = URL.createObjectURL(new Blob([wav], {type:'audio/wav'}));
      const a = document.createElement('a'); a.href=url; a.download='maestro-render.wav'; a.click();
      URL.revokeObjectURL(url);
      dlInfo.textContent = 'Saved WAV via quick render.';
    }catch(e){
      dlInfo.textContent = 'Offline render failed here. Use Live Record instead.';
      console.error(e);
    }
  }

  // WAV encoder
  function bufferToWav(buffer){
    const numOfChan = buffer.numberOfChannels;
    const btw = (view, offset, string) => { for (let i=0;i<string.length;i++) view.setUint8(offset+i, string.charCodeAt(i)); };
    const sampleRate = buffer.sampleRate;
    const length = buffer.length * numOfChan * 2 + 44;
    const result = new ArrayBuffer(length);
    const view = new DataView(result);
    btw(view, 0, 'RIFF'); view.setUint32(4, 36 + buffer.length * numOfChan * 2, true);
    btw(view, 8, 'WAVE'); btw(view, 12, 'fmt '); view.setUint32(16, 16, true);
    view.setUint16(20, 1, true); view.setUint16(22, numOfChan, true);
    view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * numOfChan * 2, true);
    view.setUint16(32, numOfChan * 2, true); view.setUint16(34, 16, true); btw(view, 36, 'data');
    view.setUint32(40, buffer.length * numOfChan * 2, true);
    // interleave + write
    const channels = []; for (let i=0;i<numOfChan;i++) channels.push(buffer.getChannelData(i));
    let offset = 44;
    for (let i=0;i<buffer.length;i++){
      for (let ch=0; ch<numOfChan; ch++){
        let s = Math.max(-1, Math.min(1, channels[ch][i]));
        view.setInt16(offset, s<0 ? s*0x8000 : s*0x7FFF, true); offset += 2;
      }
    }
    return result;
  }
// ======= Background-safe audio element playback =======
async function renderPresetToWavBlob(preset, gain=0.9){
  const sr = 44100;
  const len = preset.lengthSec * sr;
  const off = new OfflineAudioContext(1, len, sr);

  const master = off.createGain(); master.gain.value = parseFloat(gain||"0.9"); master.connect(off.destination);

  function makeSquareShaper(offctx){
    const sh = offctx.createWaveShaper();
    const curve = new Float32Array(256);
    for (let i=0;i<256;i++){ const x=(i/255)*2-1; curve[i]=(x>=0?1:-1); }
    sh.curve = curve; sh.oversample = '4x'; return sh;
  }
  function makeIsoGate(pStart,pEnd,t0,dur){
    const lfo = off.createOscillator();
    const shaper = makeSquareShaper(off);
    const g = off.createGain(); const bias = off.createConstantSource();
    lfo.type='sine'; lfo.connect(shaper); const lfoGain=off.createGain(); shaper.connect(lfoGain);
    lfoGain.gain.value=0.5; bias.offset.value=0.5; lfoGain.connect(g.gain); bias.connect(g.gain);
    lfo.frequency.setValueAtTime(pStart, t0); lfo.frequency.linearRampToValueAtTime(pEnd, t0+dur);
    lfo.start(t0); bias.start(t0); return {node:g};
  }

  preset.stages.forEach(([s,dur,freqs,p0,p1,vols])=>{
    const gate = makeIsoGate(p0,p1,s,dur).node;
    const stageMaster = off.createGain(); gate.connect(stageMaster).connect(master);
    freqs.forEach((f,i)=>{
      const osc = off.createOscillator(); const g=off.createGain();
      osc.type='sine'; osc.frequency.setValueAtTime(f, s);
      g.gain.setValueAtTime((vols && vols[i]!=null)?vols[i]:0.5, s);
      osc.connect(g).connect(gate); osc.start(s); osc.stop(s+dur+0.02);
    });
    const T=preset.lengthSec;
    if (s+dur>=T && s<=T-15){
      const fade = stageMaster.gain;
      fade.linearRampToValueAtTime(fade.value, T-15);
      fade.linearRampToValueAtTime(0.0001, T);
    }
  });

  const buf = await off.startRendering();
  // WAV encode (reuses your encoder)
  const wav = bufferToWav(buf);
  return new Blob([wav], {type:'audio/wav'});
}

let usingBg = false;
let bgURL = null;
const bgAudio = document.getElementById('bgPlayer');

async function playPresetAsAudioElement(preset, loop=true){
  setStatus('Rendering…');
  // build WAV blob of the whole preset (simple & reliable), then play
  const blob = await renderPresetToWavBlob(preset, masterVol.value);
  if (bgURL) URL.revokeObjectURL(bgURL);
  bgURL = URL.createObjectURL(blob);

  bgAudio.src = bgURL;
  bgAudio.loop = loop;
  usingBg = true;

  // wire lock‑screen controls
  if ('mediaSession' in navigator){
    navigator.mediaSession.metadata = new MediaMetadata({
      title: preset.name, artist: 'Maestro Lab', album: 'Logan Sessions'
    });
    navigator.mediaSession.setActionHandler('play', ()=> bgAudio.play());
    navigator.mediaSession.setActionHandler('pause', ()=> bgAudio.pause());
    navigator.mediaSession.setActionHandler('seekto', e => { if (typeof e.seekTime==='number') bgAudio.currentTime = e.seekTime; });
    navigator.mediaSession.playbackState = 'playing';
  }

  // seek to slider pos (after metadata loads)
  const target = parseInt(seekEl.value||'0',10);
  await bgAudio.play().catch(()=>{});
  if (!isNaN(target) && target>0) {
    const setT = ()=>{ bgAudio.currentTime = Math.min(target, selectedPreset.lengthSec); bgAudio.removeEventListener('loadedmetadata', setT); };
    if (isFinite(bgAudio.duration)) setT(); else bgAudio.addEventListener('loadedmetadata', setT);
  }

  // UI state
  startBtn.disabled = true; stopBtn.disabled = false; pauseBtn.disabled = false; resumeBtn.disabled = true;
  recordBtn.disabled = true; saveBtn.disabled = true; // recording is for live WebAudio path
  setStatus('Playing in background ✓', true);

  // clock + seek sync
  const onTime = ()=>{
    seekEl.value = Math.min(selectedPreset.lengthSec, Math.floor(bgAudio.currentTime));
    clockEl.textContent = `${fmt(seekEl.value)} / ${fmt(selectedPreset.lengthSec)}`;
  };
  bgAudio.addEventListener('timeupdate', onTime);
  bgAudio.addEventListener('ended', ()=>{ setStatus('Done • '+fmt(selectedPreset.lengthSec)); });
}

function pauseBg(){
  if (!usingBg) return;
  bgAudio.pause();
  setStatus('Paused');
  pauseBtn.disabled = true; resumeBtn.disabled = false;
}
async function resumeBg(){
  if (!usingBg) return;
  await bgAudio.play().catch(()=>{});
  setStatus('Playing…');
  pauseBtn.disabled = false; resumeBtn.disabled = true;
}
function stopBg(){
  if (!usingBg) return;
  bgAudio.pause();
  bgAudio.currentTime = 0;
  if (bgURL) { URL.revokeObjectURL(bgURL); bgURL = null; }
  usingBg = false;
  startBtn.disabled=false; stopBtn.disabled=true; pauseBtn.disabled=true; resumeBtn.disabled=true;
  seekEl.value=0; clockEl.textContent=`00:00 / ${fmt(selectedPreset.lengthSec)}`;
  setStatus('Stopped.');
}

// Keep audio alive when unlocking screen
document.addEventListener('visibilitychange', ()=>{
  if (document.visibilityState === 'visible' && usingBg && bgAudio.paused === false){
    bgAudio.play().catch(()=>{});
  }
});
const IS_MOBILE = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
const CHUNK_SEC = 600; // 15 min chunks (use 600 for 10 min if needed)
let chunkQueue = [];   // [{idx, url, blob}]
let currentChunk = 0;
let prefetching = false;

async function renderPresetChunkToWavBlob(preset, chunkIdx, chunkSec = CHUNK_SEC, gain=0.9){
  const sr = 22050; // lower SR for mobile memory relief (sounds fine for monaural)
  const t0 = chunkIdx * chunkSec;
  const t1 = Math.min(preset.lengthSec, t0 + chunkSec);
  const dur = Math.max(0, t1 - t0);
  if (dur <= 0) return null;

  const off = new OfflineAudioContext(1, dur * sr, sr);
  const master = off.createGain(); master.gain.value = parseFloat(gain||"0.9"); master.connect(off.destination);

  function makeSquareShaper(ctx){
    const sh = ctx.createWaveShaper();
    const curve = new Float32Array(256);
    for (let i=0;i<256;i++){ const x=(i/255)*2-1; curve[i]=(x>=0?1:-1); }
    sh.curve=curve; sh.oversample='4x'; return sh;
  }
  function makeIsoGate(ctx, pStart,pEnd,t0Local,dLocal){
    const lfo = ctx.createOscillator();
    const shaper = makeSquareShaper(ctx);
    const lfoGain = ctx.createGain();
    const bias = ctx.createConstantSource();
    const gate = ctx.createGain();

    lfo.type='sine'; lfo.connect(shaper); shaper.connect(lfoGain);
    lfoGain.gain.value=0.5; bias.offset.value=0.5;
    lfoGain.connect(gate.gain); bias.connect(gate.gain);
    lfo.frequency.setValueAtTime(pStart, t0Local);
    lfo.frequency.linearRampToValueAtTime(pEnd, t0Local + dLocal);
    lfo.start(t0Local); bias.start(t0Local);
    return {gate, stop:(t)=>{ try{lfo.stop(t);}catch(_){} try{bias.stop(t);}catch(_){}}};
  }

  // schedule only the portion of each stage that overlaps [t0,t1)
  const T = preset.lengthSec;
  preset.stages.forEach(([s,d,freqs,p0,p1,vols])=>{
    const S = s, E = s + d;
    if (E <= t0 || S >= t1) return; // no overlap
    const segStart = Math.max(S, t0);
    const segEnd   = Math.min(E, t1);
    const segDur   = segEnd - segStart;
    const localStart = segStart - t0;

    // interpolate pulse at seg boundaries
    const rel0 = (segStart - S) / d;
    const rel1 = (segEnd   - S) / d;
    const pStart = p0 + (p1 - p0) * rel0;
    const pEnd   = p0 + (p1 - p0) * rel1;

    const {gate} = makeIsoGate(off, pStart, pEnd, localStart, segDur);
    const stageMaster = off.createGain(); gate.connect(stageMaster).connect(master);

    freqs.forEach((f,i)=>{
      const osc = off.createOscillator();
      const g = off.createGain();
      osc.type='sine';
      osc.frequency.setValueAtTime(f, localStart);
      const vol = (vols && vols[i]!=null)?vols[i]:0.5;
      g.gain.setValueAtTime(vol, localStart);
      osc.connect(g).connect(gate);
      osc.start(localStart);
      osc.stop(localStart + segDur + 0.02);
    });

    // fade the TRUE end of the whole preset only if final chunk reaches T
    if (segEnd >= T && S <= T-15){
      stageMaster.gain.linearRampToValueAtTime(stageMaster.gain.value, T - segStart - 15);
      stageMaster.gain.linearRampToValueAtTime(0.0001, localStart + segDur);
    }
  });

  const buf = await off.startRendering();
  const wav = bufferToWav(buf);
  return new Blob([wav], {type:'audio/wav'});
}

async function ensureChunkReady(preset, idx){
  if (chunkQueue.find(c => c.idx===idx)) return; // already there
  if (idx*CHUNK_SEC >= preset.lengthSec) return;

  prefetching = true;
  setStatus(`Rendering chunk ${idx+1}…`);
  const blob = await renderPresetChunkToWavBlob(preset, idx, CHUNK_SEC, masterVol.value);
  if (!blob){ prefetching=false; return; }
  const url = URL.createObjectURL(blob);
  chunkQueue.push({idx, url, blob});
  // keep only two in memory: current and next
  chunkQueue = chunkQueue
    .sort((a,b)=>a.idx-b.idx)
    .filter(c => c.idx >= currentChunk && c.idx <= currentChunk+1);
  prefetching = false;
}

function getChunkUrl(idx){
  const hit = chunkQueue.find(c => c.idx===idx);
  return hit ? hit.url : null;
}

async function playPresetChunked(preset){
  usingBg = true;
  currentChunk = Math.floor((parseInt(seekEl.value||'0',10))/CHUNK_SEC);
  chunkQueue = [];

  // render current and next
  await ensureChunkReady(preset, currentChunk);
  ensureChunkReady(preset, currentChunk+1); // fire-and-forget

  const loadAndPlay = async (idx, startAtSec=0)=>{
    const url = getChunkUrl(idx);
    if (!url){ await ensureChunkReady(preset, idx); }
    const useUrl = getChunkUrl(idx);
    if (!useUrl){ setStatus('Chunk render failed.', false); return; }

    const audio = document.getElementById('bgPlayer');
    audio.src = useUrl;
    audio.loop = false;

    // Media Session (lock‑screen)
    if ('mediaSession' in navigator){
      navigator.mediaSession.metadata = new MediaMetadata({
        title: `${preset.name} — part ${idx+1}`,
        artist: 'Maestro Lab',
        album: 'Logan Sessions'
      });
      navigator.mediaSession.setActionHandler('play', ()=> audio.play());
      navigator.mediaSession.setActionHandler('pause', ()=> audio.pause());
      navigator.mediaSession.setActionHandler('seekto', e => {
        if (typeof e.seekTime==='number'){
          const globalT = e.seekTime;
          const newIdx = Math.floor(globalT/CHUNK_SEC);
          const within = globalT - newIdx*CHUNK_SEC;
          currentChunk = newIdx;
          loadAndPlay(newIdx, within);
        }
      });
    }

    await audio.play().catch(()=>{});
    // seek within this chunk if needed
    audio.currentTime = Math.min(startAtSec, CHUNK_SEC);

    // clock
    const onTime = ()=>{
      const globalTime = currentChunk*CHUNK_SEC + Math.floor(audio.currentTime);
      seekEl.value = Math.min(preset.lengthSec, globalTime);
      clockEl.textContent = `${fmt(globalTime)} / ${fmt(preset.lengthSec)}`;
    };
    audio.onended = async ()=>{
      // free past chunk
      const past = chunkQueue.find(c=>c.idx===currentChunk);
      if (past){ URL.revokeObjectURL(past.url); }
      currentChunk++;
      if (currentChunk*CHUNK_SEC >= preset.lengthSec){
        setStatus('Done • '+fmt(preset.lengthSec));
        stopBg();
        return;
      }
      // prefetch next
      ensureChunkReady(preset, currentChunk+1);
      // play next (startAt 0)
      loadAndPlay(currentChunk, 0);
    };
    audio.ontimeupdate = onTime;

    // UI state
    startBtn.disabled = true; stopBtn.disabled = false; pauseBtn.disabled = false; resumeBtn.disabled = true;
    setStatus(`Playing (part ${idx+1}) ✓`, true);
  };

  // figure initial offset within the first chunk
  const initialGlobal = parseInt(seekEl.value||'0',10);
  const within = initialGlobal - currentChunk*CHUNK_SEC;
  await loadAndPlay(currentChunk, Math.max(0, within));
}

  // ======= UI Events =======
// Prefer background-safe audio element on all devices (works on desktop too)
startBtn.onclick = async ()=>{
  seekEl.max = selectedPreset.lengthSec;
  clockEl.textContent = `00:00 / ${fmt(selectedPreset.lengthSec)}`;

  const isLong = selectedPreset.lengthSec > CHUNK_SEC; // longer than 15 min
  if (IS_MOBILE && isLong){
    await playPresetChunked(selectedPreset);   // <-- chunked path (mobile-friendly)
  } else {
    await playPresetAsAudioElement(selectedPreset, true); // <-- whole-file path
  }
};

stopBtn.onclick   = ()=> usingBg ? stopBg()   : stopAll();
pauseBtn.onclick  = ()=> usingBg ? pauseBg()  : pause();
resumeBtn.onclick = ()=> usingBg ? resumeBg() : resume();


  seekEl.oninput = ()=>{ seekHint.textContent = 'Cue to '+fmt(parseInt(seekEl.value,10)); };
 seekEl.onchange = ()=>{
  const t = parseInt(seekEl.value,10) || 0;
  if (usingBg){
    bgAudio.currentTime = Math.min(t, selectedPreset.lengthSec);
  } else if (running){
    startAt(t); // legacy live WebAudio path
  }
};


  masterVol.oninput = ()=>{ if (master) master.gain.value=parseFloat(masterVol.value||"0.9"); };

  recordBtn.onclick = startRecord;
  saveBtn.onclick   = stopRecord;
  offlineBtn.onclick= quickRender;

  // Enable/disable record controls based on support
  if (!('MediaRecorder' in window)){ recordBtn.disabled=true; saveBtn.disabled=true; dlInfo.textContent='Recorder not supported here; use Quick Render on desktop.'; }

})();
</script>
</body>
</html>
