<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Maestro Player — Wet Plap Crescendo</title>
<style>
  :root { --bg:#0b0b0f; --fg:#e8e8ee; --muted:#9aa0a6; --accent:#6ee7b7; --card:#14141a; }
  html,body{background:var(--bg);color:var(--fg);font-family:-apple-system, system-ui, Segoe UI, Roboto, Arial, sans-serif;margin:0}
  .wrap{max-width:820px;margin:24px auto;padding:0 16px}
  h1{font-size:22px;margin:12px 0 4px}
  p{color:var(--muted);margin:6px 0}
  .card{background:var(--card);border:1px solid #22232a;border-radius:14px;padding:14px;margin:12px 0}
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button,.btn{background:#111827;color:#f9fafb;border:1px solid #1f2937;border-radius:12px;padding:12px 16px;cursor:pointer}
  button:disabled{opacity:.6;cursor:not-allowed}
  input,textarea,select{background:#0f1117;color:var(--fg);border:1px solid #1f2230;border-radius:10px;padding:10px;width:100%}
  .pill{padding:6px 10px;border-radius:999px;background:#1b1e27;color:#cbd5e1;border:1px solid #2a2f3b}
  .accent{color:var(--accent)}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;font-size:12px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media (max-width:720px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="wrap">
  <h1>Maestro Player <span class="pill">Web Audio</span></h1>
  <p>Tap <b>Start</b> once (iOS needs a user gesture). Keep Safari foregrounded and Silent Mode off. Headphones recommended.</p>

  <div class="card">
    <div class="row">
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
      <span id="status" class="pill">Idle</span>
    </div>
    <div class="row">
      <span id="clock">00:00 / 15:00</span>
    </div>
  </div>

  <div class="card">
    <div class="grid">
      <div>
        <label>Preset</label>
        <select id="presetSelect"></select>
        <p class="mono" id="presetInfo"></p>
      </div>
      <div>
        <label>Master Volume</label>
        <input id="masterVol" type="range" min="0" max="1" step="0.01" value="0.9">
      </div>
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">Import Custom Preset (JSON)</h3>
    <p class="mono">Format: {"name":"My Preset","lengthSec":900,"stages":[[startSec,durationSec,[freqs...],pulseStartHz,pulseEndHz,[vols...]], ...]}</p>
    <textarea id="presetJson" rows="6" placeholder='Paste preset JSON here'></textarea>
    <div class="row" style="margin-top:8px">
      <button id="loadJson">Load JSON Preset</button>
    </div>
  </div>

  <div class="card">
    <h3 style="margin:0 0 8px">What this does</h3>
    <ul>
      <li>Monaural sine oscillators layered at target resonances (38 / 74 / 18 / 120 Hz; then 20 Hz drop)</li>
      <li>Isochronic gate (sine→square waveshaper) ramping pulse per stage</li>
      <li>Preprogrammed 5-stage crescendo totaling 15:00</li>
    </ul>
  </div>
</div>

<script>
(() => {
  // ======= Built-in presets =======
  const PRESETS = [
    {
      name: "Wet Plap Crescendo (15:00)",
      lengthSec: 900,
      stages: [
        // [startSec, durationSec, baseFreqs[], pulseStartHz, pulseEndHz, volumes[]]
        [   0, 180, [38],                 1.5, 2.0, [0.60] ],
        [ 180, 240, [38, 74],             2.0, 3.5, [0.75, 0.50] ],
        [ 420, 240, [38, 74, 18],         3.5, 5.0, [0.85, 0.50, 0.40] ],
        [ 660, 180, [38, 74, 18, 120],    5.0, 7.5, [1.00, 0.60, 0.50, 0.50] ],
        [ 840,  60, [20, 38],             1.0, 1.0, [0.80, 0.30] ]
      ]
    }
  ];

  // ======= DOM =======
  const startBtn = document.getElementById('startBtn');
  const stopBtn  = document.getElementById('stopBtn');
  const statusEl = document.getElementById('status');
  const clockEl  = document.getElementById('clock');
  const presetSel= document.getElementById('presetSelect');
  const presetInfo = document.getElementById('presetInfo');
  const presetJson = document.getElementById('presetJson');
  const loadJsonBtn = document.getElementById('loadJson');
  const masterVol = document.getElementById('masterVol');

  let ctx, master, running=false, rafId=null, startPerf=0, activeNodes=[];
  let selectedPreset = PRESETS[0];

  // Populate presets
  function refreshPresetList() {
    presetSel.innerHTML = "";
    PRESETS.forEach((p, i) => {
      const opt = document.createElement('option');
      opt.value = i;
      opt.textContent = p.name;
      presetSel.appendChild(opt);
    });
    presetSel.value = PRESETS.indexOf(selectedPreset);
    presetInfo.textContent = `${selectedPreset.name} • ${Math.round(selectedPreset.lengthSec/60)} min`;
  }
  refreshPresetList();

  presetSel.addEventListener('change', () => {
    selectedPreset = PRESETS[parseInt(presetSel.value,10)];
    presetInfo.textContent = `${selectedPreset.name} • ${Math.round(selectedPreset.lengthSec/60)} min`;
  });

  loadJsonBtn.addEventListener('click', () => {
    try {
      const obj = JSON.parse(presetJson.value.trim());
      if (!obj || !obj.name || !obj.stages || !Array.isArray(obj.stages)) throw new Error("Invalid preset JSON.");
      if (!obj.lengthSec) {
        // Infer from last stage
        let maxEnd = 0;
        obj.stages.forEach(s => { maxEnd = Math.max(maxEnd, s[0]+s[1]); });
        obj.lengthSec = maxEnd;
      }
      PRESETS.push(obj);
      selectedPreset = obj;
      refreshPresetList();
      status("Loaded custom preset.", true);
    } catch(e) {
      status("Preset JSON error: " + e.message, false);
    }
  });

  function status(msg, ok=true){
    statusEl.textContent = msg;
    statusEl.style.background = ok ? "#11321f" : "#3a1313";
    statusEl.style.color = ok ? "#c7f9cc" : "#fca5a5";
  }

  function formatTime(sec){
    const m = Math.floor(sec/60), s = Math.floor(sec%60);
    return `${m}:${s<10?'0'+s:s}`;
  }

  function stopAll() {
    running=false;
    if (rafId) cancelAnimationFrame(rafId);
    try { if (activeNodes) activeNodes.forEach(n => n.stop && n.stop(ctx.currentTime+0.01)); } catch(e){}
    activeNodes=[];
    try { if (ctx && ctx.state!=="closed") ctx.close(); } catch(e){}
    startBtn.disabled=false; stopBtn.disabled=true;
    status("Stopped.", true);
  }

  function makeIsoGate(pStart, pEnd, t0, dur){
    const lfo = ctx.createOscillator();
    const shaper = ctx.createWaveShaper();
    const lfoGain = ctx.createGain();
    const bias = ctx.createConstantSource();
    const gate = ctx.createGain();

    // waveshaper to approximate square
    const curve = new Float32Array(256);
    for (let i=0;i<256;i++){ const x=(i/255)*2-1; curve[i]=(x>=0?1:-1); }
    shaper.curve = curve; shaper.oversample = '4x';

    lfo.type='sine';
    lfo.connect(shaper);
    shaper.connect(lfoGain);
    lfoGain.gain.value = 0.5;

    bias.offset.value = 0.5;
    lfoGain.connect(gate.gain);
    bias.connect(gate.gain);

    lfo.frequency.setValueAtTime(pStart, t0);
    lfo.frequency.linearRampToValueAtTime(pEnd, t0+dur);

    lfo.start(t0); bias.start(t0);

    return {
      node: gate,
      stop: (t)=>{ try{lfo.stop(t);}catch(e){} try{bias.stop(t);}catch(e){} }
    };
  }

  function scheduleStage(stage){
    const [startSec, durSec, freqs, pStart, pEnd, vols] = stage;
    const t0 = ctx.currentTime + startSec + 0.05;

    const gateObj = makeIsoGate(pStart, pEnd, t0, durSec);
    const stageMaster = ctx.createGain();
    stageMaster.gain.setValueAtTime(1.0, t0);
    gateObj.node.connect(stageMaster).connect(master);

    freqs.forEach((f, idx) => {
      const osc = ctx.createOscillator();
      const g = ctx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(f, t0);
      g.gain.setValueAtTime((vols && vols[idx] != null) ? vols[idx] : 0.5, t0);
      osc.connect(g).connect(gateObj.node);
      osc.start(t0);
      osc.stop(t0 + durSec + 0.02);
      activeNodes.push({stop:(t)=>{try{osc.stop(t);}catch(e){}}});
    });

    // fade out final stage last 15s
    if (startSec + durSec >= selectedPreset.lengthSec && startSec <= selectedPreset.lengthSec-15) {
      const fadeStart = t0 + durSec - 15;
      stageMaster.gain.linearRampToValueAtTime(stageMaster.gain.value, fadeStart);
      stageMaster.gain.linearRampToValueAtTime(0.0001, t0 + durSec);
    }

    activeNodes.push({stop: gateObj.stop});
  }

  async function start() {
    if (running) return;
    running = true;
    startBtn.disabled = true; stopBtn.disabled = false;

    try {
      ctx = new (window.AudioContext || window.webkitAudioContext)({latencyHint:"interactive"});
      if (ctx.state === 'suspended') await ctx.resume();
    } catch(e) {
      status("AudioContext failed: " + e, false);
      startBtn.disabled=false; stopBtn.disabled=true; running=false;
      return;
    }

    master = ctx.createGain();
    master.gain.value = parseFloat(masterVol.value || "0.9");
    master.connect(ctx.destination);

    // schedule all stages
    selectedPreset.stages.forEach(scheduleStage);
    status("Playing…", true);

    // timer
    const totalMs = selectedPreset.lengthSec * 1000;
    startPerf = performance.now();
    const tick = () => {
      if (!running) return;
      const elapsed = performance.now() - startPerf;
      const remain = Math.max(0, totalMs - elapsed);
      clockEl.textContent = `${formatTime(elapsed/1000)} / ${formatTime(selectedPreset.lengthSec)}`
      if (remain <= 0) {
        stopAll();
        status("Done • " + formatTime(selectedPreset.lengthSec), true);
      } else {
        rafId = requestAnimationFrame(tick);
      }
    };
    rafId = requestAnimationFrame(tick);
  }

  // iOS tips: make sure ringer is on & volume up
  startBtn.addEventListener('click', async ()=>{
    try { if (ctx && ctx.state==='suspended') await ctx.resume(); } catch(e){}
    start();
  });
  stopBtn.addEventListener('click', stopAll);
  masterVol.addEventListener('input', ()=>{ if(master) master.gain.value = parseFloat(masterVol.value||"0.9"); });

})();
</script>
</body>
</html>
